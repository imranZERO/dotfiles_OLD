vim9script

# O------------------------------------------------------------------O
# |  Essentials                                                      |
# O------------------------------------------------------------------O
set nocompatible encoding=utf-8 hidden confirm
\ path+=** noswapfile nobackup fileformats=unix,dos
\ history=1024 magic secure hlsearch incsearch
\ exrc wildmenu showcmd nomodeline noshowmode
\ ignorecase smartcase autoindent smartindent
\ autoread lazyredraw ttyfast splitbelow splitright
\ notimeout ttimeout ttimeoutlen=200 nostartofline
\ mouse=a laststatus=2 nrformats-=octal linespace=0
\ shiftwidth=0 tabstop=4 softtabstop=4 expandtab
\ breakindent showbreak=» foldcolumn=1 belloff=all
\ scrolloff=6 sidescrolloff=12 sidescroll=1 synmaxcol=400
\ nonumber numberwidth=5 fillchars=vert:\│, termguicolors
\ backspace=indent,eol,start shortmess+=I shortmess-=S
\ listchars=tab:\·\ ,space:·,precedes:<,extends:>,eol:¬
\ virtualedit=block cursorlineopt=screenline commentstring=#\ %s
\ wildignore=*.o,*.pyc,*.dll,*.png,*.jpg,*.gif,*.pdf
\ wildmode=full wildoptions=fuzzy,pum,tagfile title titlestring=
\ titlestring+=%t%(\ %M%)%(\ (%{expand(\"%:p:~:.:h\")}/)%)\ %{$USER}
\ titlestring+=@%{hostname()}\ :\ %{substitute(getcwd(),$HOME,'~','')}

# O------------------------------------------------------------------O
# |  Plugins (with VIM8+ plugin manager)                             |
# O------------------------------------------------------------------O
# Deferred loading
def Load_Plugins(t: number)
    packadd fzf | packadd fzf.vim       # junegunn/fzf
        g:fzf_layout = { 'down': '50%' }
        g:fzf_colors = { 'border': ['fg', 'Ignore'] }
        augroup FZF | autocmd!
            autocmd FileType fzf set laststatus=0
            \| autocmd BufLeave <buffer> set laststatus=2
        augroup end
    packadd asyncdo.vim                 # hauleth/asyncdo.vim
        command! -bang -nargs=* -complete=file Make
        \ asyncdo#run(<bang>0, &makeprg, <f-args>)
    packadd vim-slime                   # jpalardy/vim-slime
        g:slime_target = "vimterminal"
    packadd rainbow_parentheses.vim     # junegunn/rainbow_parentheses
        augroup RAINBOW_PARENS | autocmd!
            autocmd FileType * RainbowParentheses
            # autocmd FileType lisp,clojure,scheme RainbowParentheses
        augroup end
    packadd vim-polyglot                # sheerun/vim-polyglot
        command! -bar -nargs=* Retab set ts=4 sw=4 sts=4 et | retab
    packadd vim-fugitive                # tpope/vim-fugitive
    packadd vim-surround                # tpope/vim-surround
    packadd vim-repeat                  # tpope/vim-repeat
    packadd multiterm.vim               # chengzeyi/multiterm.vim
    packadd vim-commentary              # tpope/vim-commentary
    packadd vim-dir                     # habamax/vim-dir
enddef
augroup USER_CMDS | autocmd!
    autocmd VimEnter * timer_start(20, function('Load_Plugins'))
augroup END

# Disable unwanted built-in plugins
g:loaded_2html_plugin = 1
g:loaded_getscriptPlugin = 1
g:loaded_logipat = 1
g:loaded_rrhelper = 1
g:loaded_gzip = 1
g:loaded_tarPlugin = 1 | g:loaded_tar = 1
g:loaded_zipPlugin = 1 | g:loaded_zip = 1
g:loaded_vimballPlugin = 1 | g:loaded_vimball = true
# g:loaded_netrwPlugin = 1 | g:loaded_netrw = true

filetype indent plugin on | syntax enable syntax on

# O------------------------------------------------------------------O
# |  Filetype Settings                                               |
# O------------------------------------------------------------------O
augroup FILETYPE_C | autocmd!
    autocmd FileType c,cpp
        \ setlocal commentstring=//\ %s
        \| setlocal cinoptions+=(0
        \| inoreabbrev /* /*  */<C-O>3h
augroup END

augroup FILETYPE_GO | autocmd!
    # packadd vim-go          # fatih/vim-go
    autocmd FileType go setlocal noexpandtab
augroup END

# Alternate C/C++ source/header
command! A g:A('e')
command! AV g:A('botright vertical split')
def g:A(cmd: string)
    var name = expand('%:r')
    var ext = tolower(expand('%:e'))
    var sources = ['c', 'cc', 'cpp', 'cxx']
    var headers = ['h', 'hh', 'hpp', 'hxx']
    for pair in [[sources, headers], [headers, sources]]
        var [set1, set2] = pair
        if index(set1, ext) >= 0
            for h in set2
                var aname = name .. '.' .. h
                for a in [aname, toupper(aname)]
                    if filereadable(a)
                        execute cmd a
                        return
                    endif
                endfor
            endfor
        endif
    endfor
enddef

def g:BuildFile()
    exec "w"
    if &filetype == 'python' | exec "vert term python %"
    elseif &filetype == 'lua'| exec "vert term lua %"
    elseif &filetype == 'lisp' | exec "vert term sbcl --script %"
    elseif &filetype == 'make' | exec "Make!" # ! prevents jumping to location of first error
    elseif &filetype == 'c'| exec "Make!"
    elseif &filetype == 'cpp' | exec "Make!"
    elseif &filetype == 'go' | exec "Make!"
    endif
enddef

# O------------------------------------------------------------------O
# |  Gui                                                             |
# O------------------------------------------------------------------O
if has("gui_running")
    set guifont=jetbrains_mono_nl_regular:h11
    def g:GuiFontMenuhandler(id: number, result: number)
        if result == 1
            set guifont=Consolas:h11
        elseif result == 2
            set guifont=Terminus:h11
        elseif result == 3
            set guifont=Fira_Mono:h11
        elseif result == 4
            set guifont=Victor_Mono:h11 | set linespace=1
        elseif result == 5
            set guifont=jetbrains_mono_nl_regular:h11
        endif
    enddef

    def g:PopupMenuFilter(id: number, key: string): bool
        if key == "\<esc>" || key == 'q'
            popup_close(id, 0)
            return false
        endif
        return popup_filter_menu(id, key)
    enddef

    set guioptions=i
    set guicursor=i-c-ci:hor10-Cursor/lCursor
    # set guicursor=n-v-c:hor30-Cursor/lCursor,ve:ver35-Cursor,o:hor50-Cursor
    # set guicursor=i-c-ci:hor10-Cursor/lCursor,r-cr:hor20-Cursor/lCursor

    g:ScrollBar = 0

    # Font resizing
    nmap <F12> :let &guifont = substitute(&guifont, '\d\+$', '\=submatch(0)+1', '')<cr>
    nmap <s-F12> :let &guifont = substitute(&guifont, '\d\+$', '\=submatch(0)-1', '')<cr>
endif

if has("gui_running") && has("win32")
    set renderoptions=type:directx

    augroup MAXIMIZED | autocmd!
        autocmd GUIEnter * simalt ~x
    augroup end

    augroup CURSORLINE | autocmd!
        autocmd WinEnter * set cursorline | autocmd WinLeave * set nocursorline
        autocmd InsertEnter * set nocursorline | autocmd InsertLeave * set cursorline
    augroup end

    # Gvim tweaks - gist.github.com/imranZERO/d4245f05fa3125e7575b33897d5339bb
    g:Alpha = 0 | g:TopMost = 0 | g:Caption = 1
    def g:GuiOpMenuhandler(id: number, result: number)
        if result == 1
            if &guioptions == 'i' | set go=imTrL | else | set go=i | endif
        elseif result == 2
            if g:Alpha == 0 | g:Alpha = 1
                \| libcallnr("vimtweak.dll", "SetAlpha", 230) | else
                \| g:Alpha = 0 | libcallnr("vimtweak.dll", "SetAlpha", 255) | endif
        elseif result == 3
            if g:TopMost == 0 | g:TopMost = 1
                \| libcallnr("vimtweak.dll", "EnableTopMost", 1) | else
                \| g:TopMost = 0 | libcallnr("vimtweak.dll", "EnableTopMost", 0) | endif
        elseif result == 4
            if g:Caption == 0 | g:Caption = 1
                \| libcallnr("vimtweak.dll", "EnableCaption", 1) | else
                \| g:Caption = 0 | libcallnr("vimtweak.dll", "EnableCaption", 0) | endif
        endif
    enddef
endif

# O------------------------------------------------------------------O
# |  Colors                                                          |
# O------------------------------------------------------------------O
def InlineColors(clear: bool = false): void
    if exists('b:prop_ids') == 1
        map(b:prop_ids, (_, p) => prop_remove({id: p}))
    endif
    b:prop_ids = []
    if clear | return | endif
    for row in range(1, line('$'))
        var current = getline(row)
        var cnt = 1
        var [hex, starts, ends] = matchstrpos(current, '#\x\{6\}', 0, cnt)
        while starts != -1
            var col_tag = "inline_color_" .. hex[1 : ]
            var col_type = prop_type_get(col_tag)
            if col_type == {}
                hlset([{name: col_tag, guifg: hex}])
                prop_type_add(col_tag, {highlight: col_tag})
            endif
            add(b:prop_ids, prop_add(row, starts + 1, {length: ends - starts, text: " \u25CF ", type: col_tag}))
            cnt += 1
            [hex, starts, ends] = matchstrpos(current, '#\x\{6\}', 0, cnt)
        endwhile
    endfor
enddef

g:gruvbox_italic = '0' | g:gruvbox_invert_selection = '0'
g:gruvbox_contrast_light = 'hard' | g:gruvbox_contrast_dark = 'medium'

colorscheme gruvbox | &bg = 'dark'
# colorscheme cake16 | &bg = 'light'
# colorscheme hybrid | &bg = 'dark'

def SelectColorScheme()
    var schemes = getcompletion('', 'color')
    def KeyHandler(id: number, key: string): bool
        var menuline = line('.', id)
        if key == "\<Enter>" || key == 'l'
            execute 'colo' schemes[menuline - 1]
        elseif key == 'j'
            win_execute(id, 'normal! j')
        elseif key == 'k'
            win_execute(id, 'normal! k')
        elseif key == "\<Esc>" || key == 'x' || key == 'q'
            popup_close(id)
        endif
        return true
    enddef
    popup_create(schemes, {
        maxheight: 20,
        minwidth: 20,
        cursorline: true,
        padding: [1, 2, 1, 2],
        filter: KeyHandler,
    })
enddef

def g:ColorConfig()
    highlight! link foldcolumn nontext
    highlight! link vertsplit nontext
    augroup TERMINAL_STATUSLINE | autocmd!
        autocmd TerminalWinOpen * setlocal statusline=%#StatusLine#\ %{g:cmode[mode()]}\ %#StatusLineNC#\ %.60f
    augroup end
    if &bg == "light"
        highlight Cursor guifg=#FFFFFF guibg=#000000 gui=NONE
        highlight Terminal guifg=#3C3836 ctermfg=249 guibg=#EBDBB2 ctermbg=0
        g:terminal_ansi_colors = [
            \ "#774f38", "#b95942", "#308444", "#996e1f", "#50707e", "#aa56b2", "#308090", "#ede4d4",
            \ "#878787", '#f10000', '#82a3b3', '#B95942', '#678797', '#afafaf', '#afafaf', '#f7efdf',]
    else
        highlight Cursor guifg=#000000 guibg=#00F700 gui=NONE cterm=NONE
        highlight Terminal guifg=#DAB98F ctermfg=249 guibg=#161616 ctermbg=0
        g:terminal_ansi_colors = [
            \ "#272822", "#f92672", "#a6e22e", "#f4bf75", "#66d9ef", "#ae81ff", "#a1efe4", "#f8f8f2",
            \ "#75715e", "#f92672", "#a6e22e", "#f4bf75", "#66d9ef", "#ae81ff", "#a1efe4", "#f9f8f5",]
    endif
enddef
g:ColorConfig()
augroup COLORCONFIG | autocmd!
    autocmd ColorScheme * g:ColorConfig()
augroup end

# O------------------------------------------------------------------O
# |  Misc.                                                           |
# O------------------------------------------------------------------O
def Intro()
    if argc() || line2byte('$') != -1 || v:progname !~? '^[-gmnq]\=vim\=x\=\%[\.exe]$' || &insertmode
    return | endif | enew | setlocal bh=wipe bt=nofile nobl nocuc nocul nolist nonu noswf
    # append(0, 'Unfortunately, there''s a radio connected to my brain.')
    popup_create(["             |    |    |",
                \ "            )_)  )_)  )_)",
                \ "           )___))___))___)\ ",
                \ "          )____)____)_____)\\",
                \ "        _____|____|____|____\\\__",
                \ "---------\                   /---------",
                \ " ^^^^^ ^^^^^^^^^^^^^^^^^^^^^",
                \ "   ^^^^      ^^^^     ^^^    ^^",
                \ "        ^^^^      ^^^",
                \ "", "           Hello Sailor!"],
                \ {time: 1337, highlight: 'Normal'})
    setlocal nomodifiable nomodified
    nnoremap <silent><buffer>e :enew<cr>
    nnoremap <silent><buffer>i :enew <bar> startinsert<cr>
enddef
Intro()

g:NetrwIsOpen = 0
def ToggleNetrw()
    if g:NetrwIsOpen
        var i = bufnr("$")
        while (i >= 1)
            if (getbufvar(i, "&filetype") == "netrw")
                silent exe "bwipeout " .. i
            endif
            i -= 1
        endwhile
        g:NetrwIsOpen = 0
    else
        g:NetrwIsOpen = 1
        silent Vexplore
    endif
enddef
def g:NetrwMapping()
    nmap <buffer> h gg<cr>
    nmap <buffer> l <cr>
    nmap <buffer> . gh
    setlocal statusline=\ %f
enddef
augroup NETRWOPTIONS | autocmd!
    autocmd filetype netrw call NetrwMapping()
    # Quit Vim if Netrw is the only window
    autocmd WinEnter * if winnr('$') == 1 && getbufvar(winbufnr(winnr()), "&filetype") == "netrw"|q|endif
augroup end
g:netrw_banner = 0                  # Disable Header
g:netrw_winsize = -28               # Absolute width of netrw window
g:netrw_liststyle = 3               # Tree-view
g:netrw_sort_sequence = '[\/]$,*'   # Sort is affecting only: directories on the top, files below
g:netrw_browse_split = 4            # Use the previous window to open file

def ToggleIndentGuides()
    if (&tabstop == 2)
        set listchars=tab:\·\ ,leadmultispace:\·\ ,
    elseif (&tabstop == 4)
        set listchars=tab:\·\ ,leadmultispace:\·\ \ \ ,
    elseif (&tabstop == 8)
        set listchars=tab:\·\ ,leadmultispace:\·\ \ \ \ \ \ \ ,
    endif
    set list!
enddef

function ToggleMaximizeSplit(zoom)
    if exists("t:restore_zoom") && (a:zoom == v:true || t:restore_zoom.win != winnr())
        exec t:restore_zoom.cmd
        unlet t:restore_zoom
    elseif a:zoom
        let t:restore_zoom = { 'win': winnr(), 'cmd': winrestcmd() }
        exec "normal \<C-W>\|\<C-W>_"
    endif
endfunction

g:distractionFree = 0
def DistractionFree()
    if (g:distractionFree == 0)
        g:distractionFree = 1
        set laststatus=0 showtabline=0 fillchars=vert:\ ,
        highlight! EndOfBuffer guifg=bg
        wincmd o | lefta vnew | vertical resize 34
        wincmd w | vnew | vertical resize 34 | wincmd h
    else
        g:distractionFree = 0
        set laststatus=2 showtabline=1 fillchars=vert:\│,
        highlight! link EndOfBuffer Comment
        wincmd h | bw | wincmd l | bw
    endif
enddef

# Toggle colorcolumn at cursor position & set vartabstop accordingly
def ToggleColorColumn(all: bool = false)
    if all
        b:cc = &cc ?? get(b:, "cc", "80")
        &cc = empty(&cc) ? b:cc : ""
    else
        var col = virtcol('.')
        var cc = split(&cc, ",")->map((_, v) => str2nr(v))
        if index(cc, col) == -1
            exe "set cc=" .. cc->add(col)->sort('f')->map((_, v) => printf("%s", v))->join(',')
        else
            exe "set cc-=" .. col
        endif
    endif
    var cc = split(&cc, ",")->map((_, v) => str2nr(v))
    if len(cc) > 1 || len(cc) == 1 && cc[0] < 60
        setlocal varsofttabstop&
        var shift = 1
        for v in cc
            if v == 1 | continue | endif
            exe "set vsts+=" .. (v - shift)
            shift = v
        endfor
        exe "setl vsts+=" .. &sw
    else
        setlocal varsofttabstop&
    endif
enddef

def LineHighlight()
    highlight LineHighlight guifg=black guibg=white
    matchadd('LineHighlight', '\%' .. line('.') .. 'l')
enddef

# Set tab width to n spaces
command! -nargs=1 SetTab SetTab(<args>)
def SetTab(n: number)
    &tabstop = n | &softtabstop = n | &shiftwidth = n
    set expandtab
enddef

def g:FileSize(): string
    var bytes = getfsize(expand('%:p'))
    if (bytes <= 0)
        return ''
    endif
    if (bytes >= 1024)
        return bytes / 1024 .. 'KB'
    endif
    return bytes .. 'B'
enddef

set tabline=%!MyTabline()
def g:GetCurrBufNames(tabCount: number): dict<any>
    var bufNames = {}
    for i in range(tabCount)
        var tabNum = i + 1 | var winNum = tabpagewinnr(tabNum)
        var buflist = tabpagebuflist(tabNum) | var bufNum = buflist[winNum - 1]
        var bufName = bufname(bufNum)
        if bufName !=# '' | bufName = fnamemodify(bufName, ':~:.') | endif
        var baseName = fnamemodify(bufName, ':t')
        bufNames[tabNum] = {} | bufNames[tabNum]['fn'] = bufName
        bufNames[tabNum]['bn'] = baseName | bufNames[tabNum]['sn'] = baseName
    endfor
    return bufNames
enddef
def g:MyTabline(): string
    var s = ''
    var tabCount = tabpagenr('$') | var bufNames = g:GetCurrBufNames(tabCount)
    for i in range(tabCount)
        var tabNum = i + 1 | var winNum = tabpagewinnr(tabNum)
        var buflist = tabpagebuflist(tabNum) | var bufNum = buflist[winNum - 1]
        var bufName = bufNames[tabNum]['sn'] | var bufmodified = 0
        for b in buflist
            if getbufvar(b, '&modified') | bufmodified = 1 | break | endif
        endfor
        var fname = '' | var buftype = getbufvar(bufNum, '&buftype')
        if buftype ==# '' | fname = bufName !=# '' ? bufName : '[No Name]'
        elseif buftype ==# 'quickfix' | fname = '[Quickfix List]'
        elseif buftype ==# 'help' | fname = '[Help]'
        else | fname = '[' .. bufName .. ']' | endif
        var hl = tabNum == tabpagenr() ? '%#TabLineSel#' : '%#TabLine#' | s ..= hl
        s ..= '%' .. tabNum .. 'T' | s ..= ' [' .. tabNum .. '] '
        if exists('g:tabline_show_wins_count')
            var winCount = tabpagewinnr(tabNum, '$')
            if winCount > 1 | s ..= '%#TabWinsCount#' .. winCount .. hl .. ' ' | endif
        endif
        s ..= fname .. ' ' | if bufmodified | s ..= '+ ' | endif
    endfor
    s ..= '%*' .. '%=' .. '%#Normal#'
    # s ..= ' %{resolve(expand("%:p"))}%*' .. '%#Normal#' ..
    s ..=  ' [%{&fileformat}]' .. ' [%{strlen(&fenc)?&fenc:"none"}]' .. ' [%{g:FileSize()}]'
    return s
enddef

g:cmode = {
    \ "n": "NORMAL", "no": "NORMAL·OPERATOR PENDING", "v": "VISUAL", "V": "V·LINE",
    \ "\<C-V>": "V·BLOCK", "s": "SELECT", "S": "S·LINE", "^S": "S·BLOCK", "i": "INSERT",
    \ "R": "REPLACE", "Rv": "V·REPLACE", "c": "COMMAND", "cv": "VIM EX", "ce": "Ex",
    \ "r": "PROMPT", "rm": "MORE", "r?": "CONFIRM", "!": "SHELL", "t": "TERMINAL" }
def g:Statusline()
    set statusline=
    set statusline+=\ %{g:cmode[mode()]}\                       # Current mode
    set statusline+=%<                                          # Truncate
    set statusline+=%#StatusLineNC#                             # Highlight
    # set statusline+=\ [%n]                                      # Buffer number
    # set statusline+=\ %t                                        # File name
    # set statusline+=\ %f                                        # File path relative
    set statusline+=\ %.40F                                     # File path full
    # set statusline+=\ [%{g:FileSize()}]                         # File size
    # set statusline+=\ [%02p%%]                                  # Percentage
    set statusline+=\ %r%m%h                                    # Readonly,modified,help
    set statusline+=%=                                          # Right align
    set statusline+=%{exists('g:loaded_fugitive')?FugitiveHead():''}
    set statusline+=\ %*                                        # Default highlight
    set statusline+=%{exists('g:asyncdo')?'[running]':''}       # AsyncDo status
    # set statusline+=\ %{strlen(&fenc)?&fenc:'none'}\ \|         # File encoding
    # set statusline+=\ %{&fileformat}\ \\|                       # File format
    set statusline+=\ %{strlen(&ft)?&ft:'none'}\ \\|            # Filetype
    set statusline+=\ %02c:%3l/%L\                              # Column:line/total
enddef
g:Statusline()

augroup CLEAR_JUMPLIST | autocmd!
    autocmd VimEnter * exe 'clearjumps'
augroup end

augroup WINRESIZE | autocmd!
    autocmd VimResized * wincmd =
augroup end

# :t to :tabe
cnoreabbrev <expr> t getcmdtype() == ":" && getcmdline() == 't' ? 'tabe' : 't'

# Open :h in new tab
cnoreabbrev <expr> h getcmdtype() == ":" && getcmdline() == 'h' ? 'tab help' : 'h'

# Scratch buffer
command! S vnew | setlocal nobuflisted buftype=nofile bufhidden=wipe

# Universal opposite of J
def g:BreakHere()
    s/^\(\s*\)\(.\{-}\)\(\s*\)\(\%#\)\(\s*\)\(.*\)/\1\2\r\1\4\6
    histdel("/", -1)
enddef

# Better PgUp/PgDn
def MapL()
    var line = line('.')
    normal! L
    if line == line('$')
        normal! zb
    elseif line == line('.')
        normal! zt
    endif
enddef
def MapH()
    var line = line('.')
    normal! H
    if line == line('.')
        normal! zb
    endif
enddef

augroup FORMATOPTIONS | autocmd!
    autocmd FileType * setlocal formatoptions-=cro # Disable continuation of comments to the next line
    autocmd FileType * setlocal formatoptions+=j   # Remove a comment leader when joining lines
    autocmd FileType * setlocal formatoptions+=l   # Don't break a line after a one-letter word
    autocmd FileType * setlocal formatoptions+=n   # Recognize numbered lists
    autocmd FileType * setlocal formatoptions-=q   # Don't format comments
    autocmd FileType * setlocal formatoptions-=t   # Don't autowrap text using 'textwidth'
augroup END

def WipeHiddenBuffers()
    var buffers = filter(getbufinfo(), (_, v) => v.hidden)
    if !empty(buffers)
        execute 'confirm bwipeout' join(mapnew(buffers, (_, v) => v.bufnr))
    endif
enddef

# Set listchars visible in Visual Mode
# autocmd ModeChanged *:[vV\x16]* set list
# autocmd ModeChanged [vV\x16]*:* set nolist

# Remove all trailing whitespace and newlines at end of file & reset cursor position
var currPos = getpos(".")
def StripWhitespace()
    if &ft =~ 'markdown\|org'   # Excluded filetypes
        return
    endif
    currPos = getpos(".")
    exec ':%s/\s\+$//e'
    exec ':%s/\n\+\%$//e'
    cursor(currPos[1], currPos[2])
enddef
augroup STRIP_WHITESPACE | autocmd!
    autocmd BufWritePre * StripWhitespace()
augroup end

# O------------------------------------------------------------------O
# |  Mappings                                                        |
# O------------------------------------------------------------------O
inoremap <m-i> <Esc>

nnoremap <F1> <Esc>
inoremap <F1> <Esc>

nnoremap <m-j> 5j
nnoremap <m-k> 5k
vnoremap <m-j> 5j
vnoremap <m-k> 5k

noremap L <ScriptCmd>MapL()<cr>
noremap H <ScriptCmd>MapH()<cr>

nnoremap <space>G <Esc>:w<cr>
nnoremap <silent><space>q :q<cr>
tnoremap <silent><c-w>q exit<cr>
nnoremap <silent><F7> :silent call BuildFile()<cr>

# Switching tabs
nnoremap gr gT

# Swap ` and ' for marks
nnoremap ' `
nnoremap ` '

# Change into void register
nnoremap c "_c
nnoremap C "_C

# Make Y behave like other capitals
nnoremap Y y$

# Clear search highlighting & refresh statusline
nnoremap <silent><c-l> :nohlsearch<cr>:call Statusline()<cr><c-l>

# Keeping it centered
nnoremap n nzzzv
nnoremap N Nzzzv

# Reselect the last selection
nnoremap <space>gv `[v`]

# Don't lose selection when shifting sidewards
xnoremap < <gv^
xnoremap > >gv^

# Moving lines
vnoremap <c-j> :m '>+1<cr>gv=gv
vnoremap <c-k> :m '<-2<cr>gv=gv

# Access to system clipboard
xnoremap <space>y "+y
nnoremap <space>p "+p
nnoremap <space>P "+P
tnoremap <s-insert> <c-w>"+
tnoremap <c-v> <c-w>"+

# Search & Replace ('g' global, 'c' confirm)
nnoremap <space>ss :%s//gc<Left><Left><Left>
nnoremap <Space>S :%s/\<<C-r>=expand("<cword>")<cr>\>/

# Number of matches on last search
nnoremap <space>sn :%s///gn<cr>

# Search the last visual selection
nnoremap <space>sv /\%V

# Delete all occurences of selected text
xnoremap <space>d y:%s/<c-r>"//gc<cr>

# Change directory to current file
nnoremap <space>cd :cd %:p:h<cr>:pwd<cr>

# Saner command-line history
cnoremap <expr> <c-n> wildmenumode() ? "\<c-n>" : "\<down>"
cnoremap <expr> <c-p> wildmenumode() ? "\<c-p>" : "\<up>"

# Change forward/back slashes
nnoremap <silent><space>c/ :let tmp=@/<Bar>s:\\:/:ge<Bar>let @/=tmp<Bar>noh<cr>
nnoremap <silent><space>c<Bslash> :let tmp=@/<Bar>s:/:\\:ge<Bar>let @/=tmp<Bar>noh<cr>

# Fuzzy file search
nnoremap <space>. :find **

# File search
nnoremap <space>> :cd %:p:h<cr>:find <C-D>

# Perform dot commands over visual selections
xnoremap . :normal .<cr>

# J counterpart
nnoremap <silent>K :<c-u>call BreakHere()<cr>

# Auto-insert closing parenthesis/brace/quotes
inoremap ( ()<Left>
inoremap { {}<Left>
inoremap [ []<Left>
inoremap ' ''<Left>
inoremap " ""<Left>
# Expand opening-brace followed by ENTER to a block and place cursor inside
inoremap {<cr> {<cr>}<Esc>O
# Skip over closing parenthesis/brace
inoremap <expr> ) getline('.')[col('.') - 1] == ")" ? "\<Right>" : ")"
inoremap <expr> } getline('.')[col('.') - 1] == "}" ? "\<Right>" : "}"

# Terminal mode
if has("win32") && (&shell =~# '\<cmd\.exe$')
    tnoremap <silent><C-p> <up>
    tnoremap <silent><C-n> <down>
    tnoremap <silent><C-b> <left>
    tnoremap <silent><C-f> <right>
    tnoremap <silent><C-e> <end>
    tnoremap <silent><C-a> <home>
    tnoremap <silent><C-u> <esc>
    tnoremap <silent><F12> %HOME%\cmdrc.bat<cr>
    nnoremap <silent><space><cr> :vert term<cr>%HOME%\cmdrc.bat<cr>
    nnoremap <silent><space><s-cr> :term<cr>%HOME%\cmdrc.bat<cr>
    nnoremap <silent><space><c-cr> :tab :term<cr>%HOME%\cmdrc.bat<cr>
else
    nnoremap <silent><space><cr> :vert term<cr>
    nnoremap <silent><space><s-cr> :term<cr>
    nnoremap <silent><space><c-cr> :tab :term<cr>
endif

# Command mode
cnoremap <c-e> <end>
cnoremap <c-a> <home>
cnoremap <c-b> <left>
cnoremap <c-f> <right>
cnoremap <c-bs> <c-w>
cnoremap <esc> <c-c><esc>
cnoremap <m-f> <S-right>
cnoremap <m-b> <S-left>

# Insert mode (Emacs-ish)
inoremap <c-bs> <c-w>
inoremap <c-b> <left>
inoremap <c-f> <right>
inoremap <m-b> <c-left>
inoremap <m-f> <c-right>
inoremap <m-n> <c-o>j
inoremap <m-p> <c-o>k
inoremap <c-a> <home>
inoremap <c-e> <end>
inoremap <c-u> <c-g>u<c-u>
inoremap <silent><c-Up> <c-o>:<c-u>execute "keepjumps norm! " . v:count1 . "{"<cr>
inoremap <silent><c-Down> <c-o>:<c-u>execute "keepjumps norm! " . v:count1 . "}"<cr>
inoremap <s-Left> <Esc>v<c-g><Left>
inoremap <s-Right> <Esc>v<c-g><Right>
inoremap <c-s> <Esc>:w<cr>a
inoremap <c-l> <c-o><c-l>

# QuickFix
nnoremap <silent> ]q :cnext<cr>
nnoremap <silent> ]Q :clast<cr>
nnoremap <silent> [q :cprevious<cr>
nnoremap <silent> [Q :cfirst<cr>
nnoremap <silent> ]w :lnext<cr>
nnoremap <silent> ]W :llast<cr>
nnoremap <silent> [w :lprevious<cr>
nnoremap <silent> [W :lfirst<cr>

# Buffer navigation
nnoremap <bs> <c-^>
nnoremap <space>bn :bn<cr>
nnoremap <space>bp :bp<cr>
nnoremap <space>bd :bd<cr>
nnoremap <space>bw :bw<cr>
nnoremap <silent><space>bo <ScriptCmd>WipeHiddenBuffers()<cr>
nnoremap <space>, :buffers<cr>:buffer<Space>

# Split navigation
nnoremap <space>w <c-w>
tnoremap <c-space> <c-w>p
tnoremap <c-w>N <C-\><C-n>
noremap <c-space> <c-w>w

# Split Resizing
nnoremap <silent><c-Up> :res +3<cr>
nnoremap <silent><c-Down> :res -3<cr>
nnoremap <silent><c-Left> :vert res +3<cr>
nnoremap <silent><c-Right> :vert res -3<cr>

nnoremap <silent><space>wm <ScriptCmd>ToggleMaximizeSplit(v:true)<cr>

# FZF (plugin)
nnoremap <space>r :Rg<cr>
nnoremap <space>ff :FZF<cr>
nnoremap <space>fF :Files<cr>
nnoremap <space>fh :History<cr>
nnoremap <space>f: :History:<cr>
nnoremap <space>f/ :History/<cr>
nnoremap <space>fb :Buffers<cr>
nnoremap <space>fw :Windows<cr>
nnoremap <space>fm :Marks<cr>
nnoremap <space>fl :Lines<cr>
nnoremap <space>fc :Colors<cr>
# ! Opens in fullscreen
nnoremap <space>R :Rg!<cr>
nnoremap <space>Ff :FZF!<cr>
nnoremap <space>FF :Files!<cr>
nnoremap <space>Fh :History!<cr>
nnoremap <space>Fl :Lines!<cr>

# Toggles
if has("gui_running")
    if has("win32")
        nnoremap <silent><F11> :call libcallnr("vimtweak.dll", "ToggleFullScreen", 0)<cr>
        nnoremap <silent><F10> :vim9 popup_menu(['Gvim Enhancements', 'Window Transparency', 'Window Topmost', 'Window Caption'],
                 \ {filter: 'g:PopupMenuFilter', callback: 'g:GuiOpMenuhandler', title: 'GUI Options'})<cr>
    endif
    nnoremap <silent><S-F10> :vim9 popup_menu(['Consolas', 'Terminus', 'Fira Mono', 'Victor Mono', 'JetBrains Mono'],
             \ {filter: 'g:PopupMenuFilter', callback: 'g:GuiFontMenuhandler', title: 'Fonts'})<cr>
    nnoremap <silent><space>tb :if ScrollBar == 0 \| let ScrollBar = 1 \| set go+=r \| else \| let ScrollBar = 0 \| set go-=r \| endif<cr>
    nnoremap <silent><space>tg :if &guioptions == 'i' \| set go=imTrL \| else \| set go=i \| endif<cr>
endif
nnoremap <silent><c-q> :if empty(filter(getwininfo(), 'v:val.quickfix')) \| copen \| else \| cclose \| endif<cr>
nnoremap <silent><space><space> <ScriptCmd>ToggleNetrw()<cr>
nnoremap <silent><space>ti <ScriptCmd>ToggleIndentGuides()<cr>
nnoremap <silent><space>tw :set wrap! wrap?<cr>
nnoremap <silent><space>tl :set listchars=tab:\·\ ,space:·,precedes:<,extends:>,eol:¬<cr>:set list!<cr>
nnoremap <silent><space>tn :set number! number?<cr>
nnoremap <silent><space>tt :if &showtabline != 1 \| set showtabline=1 \| else \| set showtabline=2 \| endif<cr>
nnoremap <silent><space>ts :if &laststatus == 2 \| set laststatus=0 \| else \| set laststatus=2 \| endif<cr>
nnoremap <silent><space>tf :if &foldcolumn == 1 \| setlocal foldcolumn=0 \| else \| setlocal foldcolumn=1 \| endif<cr>
nnoremap <silent><space>tc <ScriptCmd>ToggleColorColumn()<cr>
nnoremap <silent><space>tC <ScriptCmd>ToggleColorColumn(true)<cr>
nnoremap <silent><space>th <ScriptCmd>LineHighlight()<cr>
nnoremap <silent><space>tH :call clearmatches()<cr>
nnoremap <silent><space>cc <ScriptCmd>InlineColors()<cr>
nnoremap <silent><F9> :let &bg=(&bg=="dark"?"light":"dark")<cr>
nnoremap <silent><S-F9> <ScriptCmd>SelectColorScheme()<cr>
nnoremap <silent><S-F11> <ScriptCmd>DistractionFree()<cr>
nmap <silent><c-z> <Plug>(Multiterm)
tmap <silent><c-z> <Plug>(Multiterm)
