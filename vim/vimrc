vim9script

# O------------------------------------------------------------------O
# |  Essentials                                                      |
# O------------------------------------------------------------------O
set nocompatible encoding=utf-8 hidden confirm
\ path+=** noswapfile nobackup fileformats=unix,dos
\ titlestring=%{resolve(expand("%:p"))}\ »\ Vim
\ history=1024 magic secure hlsearch incsearch
\ exrc wildmenu showcmd nomodeline noshowmode
\ ignorecase smartcase autoindent smartindent
\ autoread lazyredraw ttyfast splitbelow splitright
\ notimeout ttimeout ttimeoutlen=200 nostartofline
\ mouse=a laststatus=2 nrformats-=octal linespace=0
\ tabstop=4 shiftwidth=4 softtabstop=4 expandtab
\ breakindent showbreak=» foldcolumn=1 belloff=all
\ scrolloff=6 sidescrolloff=12 sidescroll=1 synmaxcol=250
\ nonumber numberwidth=5 fillchars=vert:\│, termguicolors
\ backspace=indent,eol,start shortmess+=I shortmess-=S
\ listchars+=tab:\│\ ,space:·,precedes:<,extends:>,eol:¬
\ virtualedit=block cursorlineopt=screenline commentstring=#\ %s
\ wildignore=*.o,*.exe,*.pyc,*.dll,*.png,*.jpg,*.gif,*.pdf
\ wildmode=full wildoptions=pum,tagfile

# O------------------------------------------------------------------O
# |  Plugins (with VIM8 plugin manager)                              |
# O------------------------------------------------------------------O
packadd fzf | packadd fzf.vim       # junegunn/fzf
    g:fzf_layout = { 'down': '50%' }
    g:fzf_colors = { 'border': ['fg', 'Ignore'] }
    autocmd! FileType fzf
    autocmd FileType fzf set laststatus=0
    \| autocmd BufLeave <buffer> set laststatus=2
packadd asyncdo.vim                 # hauleth/asyncdo.vim
    command! -bang -nargs=* -complete=file Make
    \ call asyncdo#run(<bang>0, &makeprg, <f-args>)
packadd vim-slime                   # jpalardy/vim-slime
    g:slime_target = "vimterminal"
packadd rainbow_parentheses.vim     # junegunn/rainbow_parentheses
    autocmd FileType * RainbowParentheses
    # autocmd FileType lisp,clojure,scheme RainbowParentheses
packadd vim-fugitive                # tpope/vim-fugitive
packadd vim-surround                # tpope/vim-surround
packadd vim-repeat                  # tpope/vim-repeat
packadd multiterm.vim               # chengzeyi/multiterm.vim
packadd vim-polyglot                # sheerun/vim-polyglot
    command! -bar -nargs=* Retab set ts=4 sw=4 sts=4 et | retab
packadd vim-commentary              # tpope/vim-commentary
packadd awesome-vim-colorschemes    # rafi/awesome-vim-colorschemes

# Disable unwanted builtin plugins
g:loaded_getscriptPlugin = true
g:loaded_logiPat = true
g:loaded_vimballPlugin = true | g:loaded_vimball = true
# g:loaded_netrwPlugin = true | g:loaded_netrw = true

filetype indent plugin on | syntax enable syntax on

# O------------------------------------------------------------------O
# |  Gui                                                             |
# O------------------------------------------------------------------O
if has("gui_running")
    # set guifont=Fixedsys:h11
    # set guifont=Fira_Mono:h11
    # set guifont=terminus:h14:b
    # set guifont=Victor_Mono:h11
    set guifont=jetbrains_mono_nl_regular:h11
    # set guifont=consolas:h11 | set linespace=-1

    set guioptions=i
    set guicursor=n-v-c:hor30-Cursor/lCursor,ve:ver35-Cursor,o:hor50-Cursor,
                \i-ci:hor10-Cursor/lCursor,r-cr:hor20-Cursor/lCursor

    g:ScrollBar = 0

    # Font resizing
    nmap <F12> :let &guifont = substitute(&guifont, '\d\+$', '\=submatch(0)+1', '')<cr>
    nmap <s-F12> :let &guifont = substitute(&guifont, '\d\+$', '\=submatch(0)-1', '')<cr>
endif

if has("gui_running") && has("win32")
    set renderoptions=type:directx
    autocmd GUIEnter * simalt ~x    # Start maximized

    augroup CURSORLINE | autocmd!
        autocmd WinEnter * set cursorline | autocmd WinLeave * set nocursorline
        autocmd InsertEnter * set nocursorline | autocmd InsertLeave * set cursorline
    augroup end

    # Gvim tweaks - gist.github.com/imranZERO/d4245f05fa3125e7575b33897d5339bb
    g:Alpha = 0
    command! SetAlpha if g:Alpha == 0 | g:Alpha = 1
        \| libcallnr("vimtweak.dll", "SetAlpha", 230) | else
        \| g:Alpha = 0 | libcallnr("vimtweak.dll", "SetAlpha", 255) | endif
    g:TopMost = 0
    command! SetTopMost if g:TopMost == 0 | g:TopMost = 1
        \| libcallnr("vimtweak.dll", "EnableTopMost", 1) | else
        \| g:TopMost = 0 | libcallnr("vimtweak.dll", "EnableTopMost", 0) | endif
    g:Caption = 1
    command! SetCaption if g:Caption == 0 | g:Caption = 1
        \| libcallnr("vimtweak.dll", "EnableCaption", 1) | else
        \| g:Caption = 0 | libcallnr("vimtweak.dll", "EnableCaption", 0) | endif
endif

# O------------------------------------------------------------------O
# |  Filetype Settings                                               |
# O------------------------------------------------------------------O
augroup FILETYPE_C | autocmd!
    autocmd FileType c,cpp
        \ setlocal commentstring=//\ %s
        \| setlocal cinoptions+=(0
        \| inoreabbrev /* /*  */<C-O>3h
augroup END

augroup FILETYPE_GO | autocmd!
    autocmd FileType go setlocal noexpandtab
augroup END

def g:BuildFile()
    exec "w"
    set cmdheight=3
    if &filetype == 'python' | exec "vert term python %"
    elseif &filetype == 'lua'| exec "vert term lua %"
    elseif &filetype == 'lisp' | exec "vert term sbcl --script %"
    elseif &filetype == 'make' | exec "Make!" # ! prevents jumping to location of first error
    elseif &filetype == 'c'| exec "Make!"
    elseif &filetype == 'cpp' | exec "Make!"
    elseif &filetype == 'go' | exec "Make!"
    endif
    set cmdheight=1
enddef

# O------------------------------------------------------------------O
# |  Misc.                                                           |
# O------------------------------------------------------------------O
function Intro()
    if argc() || line2byte('$') != -1 || v:progname !~? '^[-gmnq]\=vim\=x\=\%[\.exe]$' || &insertmode
    return | endif | enew | setlocal bh=wipe bt=nofile nobl nocuc nocul nolist nonu noswf
    call append(" ", "Unfortunately, there's a radio connected to my brain.")
    setlocal nomodifiable nomodified
    nnoremap <silent><buffer>e :enew<CR>
    nnoremap <silent><buffer>i :enew <bar> startinsert<CR>
endfunction
Intro()

g:NetrwIsOpen = 0
def g:ToggleNetrw()
    if g:NetrwIsOpen
        var i = bufnr("$")
        while (i >= 1)
            if (getbufvar(i, "&filetype") == "netrw")
                silent exe "bwipeout " .. i
            endif
            i -= 1
        endwhile
        g:NetrwIsOpen = 0
    else
        g:NetrwIsOpen = 1
        silent Vexplore
    endif
enddef
def g:NetrwMapping()
    nmap <buffer> h gg<cr>
    nmap <buffer> l <cr>
    nmap <buffer> . gh
    setlocal statusline=\ %f
enddef
augroup NETRWOPTIONS | autocmd!
    autocmd filetype netrw call NetrwMapping()
    # Quit Vim if Netrw is the only window
    autocmd WinEnter * if winnr('$') == 1 && getbufvar(winbufnr(winnr()), "&filetype") == "netrw"|q|endif
augroup end
g:netrw_banner = 0                  # Disable Header
g:netrw_winsize = -28               # Absolute width of netrw window
g:netrw_liststyle = 3               # Tree-view
g:netrw_sort_sequence = '[\/]$,*'   # Sort is affecting only: directories on the top, files below
g:netrw_browse_split = 4            # Use the previous window to open file

function g:ToggleIndentGuides()
    if !exists('b:indentguides')
        if !&expandtab && &tabstop == &shiftwidth
            let b:indentguides = 'tabs'
            let b:indentguides_listopt = &l:list
            let b:indentguides_listcharsopt = &l:listchars
            exe 'setl listchars' .. '+'[!&l:list] .. '=tab:˙\  list'
        else
            let b:indentguides = 'spaces'
            let pos = range(1, &textwidth > 0 ? &textwidth : 80, &shiftwidth)
            call map(pos, '"\\%" .. v:val .. "v"')
            let pat = '\%(\_^ *\)\@<=\%(' .. join(pos, '\|') .. '\) '
            let b:indentguides_match = matchadd('ColorColumn', pat)
        endif
    else
        if b:indentguides == 'tabs'
            let &l:list = b:indentguides_listopt
            let &l:listchars = b:indentguides_listcharsopt
            unlet b:indentguides_listopt b:indentguides_listcharsopt
        else
            call matchdelete(b:indentguides_match)
            unlet b:indentguides_match
        endif
        unlet b:indentguides
    endif
endfunction

function g:ToggleMaximizeSplit(zoom)
    if exists("t:restore_zoom") && (a:zoom == v:true || t:restore_zoom.win != winnr())
        exec t:restore_zoom.cmd
        unlet t:restore_zoom
    elseif a:zoom
        let t:restore_zoom = { 'win': winnr(), 'cmd': winrestcmd() }
        exec "normal \<C-W>\|\<C-W>_"
    endif
endfunction

g:distractionFree = 0
def g:DistractionFree()
    if (g:distractionFree == 0)
        g:distractionFree = 1
        set laststatus=0
        set showtabline=0
        set fillchars=vert:\ ,
        highlight! EndOfBuffer guifg=bg
        lefta vnew | vertical resize 34
        wincmd w
        vnew | vertical resize 34
        wincmd h
    else
        g:distractionFree = 0
        set laststatus=2
        set showtabline=1
        set fillchars=vert:\│,
        highlight! link EndOfBuffer Comment
        wincmd h | q | wincmd l | q
    endif
enddef

# Alternate C/C++ source/header
command! A call g:A('e')
command! AV call g:A('botright vertical split')
function g:A(cmd)
    let name = expand('%:r')
    let ext = tolower(expand('%:e'))
    let sources = ['c', 'cc', 'cpp', 'cxx']
    let headers = ['h', 'hh', 'hpp', 'hxx']
    for pair in [[sources, headers], [headers, sources]]
        let [set1, set2] = pair
        if index(set1, ext) >= 0
            for h in set2
                let aname = name..'.'..h
                for a in [aname, toupper(aname)]
                    if filereadable(a)
                        execute a:cmd a
                        return
                    end
                endfor
            endfor
        endif
    endfor
endfunction

# Colors
g:gruvbox_italic = '0' | g:gruvbox_invert_selection = '0'
g:gruvbox_contrast_light = 'hard' | g:gruvbox_contrast_dark = 'medium'

colorscheme gruvbox | &bg = 'dark'

g:LoopColorsInt = 0
def g:LoopColorSchemes()
    if g:LoopColorsInt == 0
        colorscheme cake16 | &bg = 'light'
    elseif g:LoopColorsInt == 1
        colorscheme gruvbox | &bg = 'dark'
    elseif g:LoopColorsInt == 2
        colorscheme hybrid | &bg = 'dark'
    endif
    g:LoopColorsInt = g:LoopColorsInt + 1
    g:LoopColorsInt = g:LoopColorsInt % 3
enddef

def g:ColorConfig()
    highlight! link foldcolumn nontext
    highlight! link vertsplit nontext
    autocmd TerminalWinOpen * setlocal statusline=%#StatusLine#\ %.60f
    if &bg == "light"
        highlight Cursor guifg=NONE guibg=#000000 gui=NONE
        highlight Terminal guifg=#3C3836 ctermfg=249 guibg=#EBDBB2 ctermbg=0
        g:terminal_ansi_colors = [
            \ "#774f38", "#b95942", "#308444", "#996e1f", "#50707e", "#aa56b2", "#308090", "#ede4d4",
            \ "#878787", '#f10000', '#82a3b3', '#B95942', '#678797', '#afafaf', '#afafaf', '#f7efdf',]
    else
        highlight Cursor guifg=NONE guibg=#00F700 gui=NONE cterm=NONE
        highlight Terminal guifg=#DAB98F ctermfg=249 guibg=#161616 ctermbg=0
        g:terminal_ansi_colors = [
            \ "#272822", "#f92672", "#a6e22e", "#f4bf75", "#66d9ef", "#ae81ff", "#a1efe4", "#f8f8f2",
            \ "#75715e", "#f92672", "#a6e22e", "#f4bf75", "#66d9ef", "#ae81ff", "#a1efe4", "#f9f8f5",]
    endif
enddef
g:ColorConfig() | autocmd ColorScheme * g:ColorConfig()

function g:FileSize()
    let bytes = getfsize(expand('%:p'))
    if (bytes >= 1024) | let kbytes = bytes / 1024 | endif
    if (exists('kbytes') && kbytes >= 1000) | let mbytes = kbytes / 1000 | endif
    if bytes <= 0 | return '0' | endif
    if (exists('mbytes')) | return mbytes .. 'MB' | elseif (exists('kbytes'))
    return kbytes .. 'KB' | else | return bytes .. 'B' | endif
endfunction

set tabline=%!MyTabline()
function g:GetCurrBufNames(tabCount)
    let bufNames = {}
    for i in range(a:tabCount)
        let tabNum = i + 1 | let winNum = tabpagewinnr(tabNum)
        let buflist = tabpagebuflist(tabNum) | let bufNum = buflist[winNum - 1]
        let bufName = bufname(bufNum)
        if bufName !=# '' | let bufName = fnamemodify(bufName, ':~:.') | endif
        let baseName = fnamemodify(bufName, ':t')
        let bufNames[tabNum] = {} | let bufNames[tabNum]['fn'] = bufName
        let bufNames[tabNum]['bn'] = baseName | let bufNames[tabNum]['sn'] = baseName
    endfor
    return bufNames
endfunction
function g:MyTabline()
    let s = ''
    let tabCount = tabpagenr('$') | let bufNames = g:GetCurrBufNames(tabCount)
    for i in range(tabCount)
        let tabNum = i + 1 | let winNum = tabpagewinnr(tabNum)
        let buflist = tabpagebuflist(tabNum) | let bufNum = buflist[winNum - 1]
        let bufName = bufNames[tabNum]['sn'] | let bufmodified = 0
        for b in buflist
            if getbufvar(b, '&modified') | let bufmodified = 1 | break | endif
        endfor
        let fname = '' | let buftype = getbufvar(bufNum, '&buftype')
        if buftype ==# '' | let fname = bufName !=# '' ? bufName : '[No Name]'
        elseif buftype ==# 'quickfix' | let fname = '[Quickfix List]'
        elseif buftype ==# 'help' | let fname = '[Help]'
        else | let fname = '[' .. bufName .. ']' | endif
        let hl = tabNum == tabpagenr() ? '%#TabLineSel#' : '%#TabLine#' | let s ..= hl
        let s ..= '%' .. tabNum .. 'T' | let s ..= ' [' .. tabNum .. '] '
        if exists('g:tabline_show_wins_count')
            let winCount = tabpagewinnr(tabNum, '$')
            if winCount > 1 | let s ..= '%#TabWinsCount#' .. winCount .. hl .. ' ' | endif
        endif
        let s ..= fname .. ' ' | if bufmodified | let s ..= '+ ' | endif
    endfor
    let s..= '%*' .. '%=' .. '%#Normal#'
    let s..= ' %{resolve(expand("%:p"))}%*' .. '%#Normal#'
    let s..= ' [%{strlen(&fenc)?&fenc:"none"}]' .. ' [%{g:FileSize()}]'
    return s
endfunction

g:cmode = {
    \ "n": "NORMAL", "no": "NORMAL·OPERATOR PENDING", "v": "VISUAL", "V": "V·LINE",
    \ "\<C-V>": "V·BLOCK", "s": "SELECT", "S": "S·LINE", "^S": "S·BLOCK", "i": "INSERT",
    \ "R": "REPLACE", "Rv": "V·REPLACE", "c": "COMMAND", "cv": "VIM EX", "ce": "Ex",
    \ "r": "PROMPT", "rm": "MORE", "r?": "CONFIRM", "!": "SHELL", "t": "TERMINAL" }
def g:Statusline()
    set statusline=
    set statusline+=\ %{g:cmode[mode()]}\                       # Current mode
    set statusline+=%<                                          # Truncate
    set statusline+=%#StatusLineNC#                             # Highlight
    # set statusline+=\ [%n]                                      # Buffer number
    # set statusline+=\ %t                                        # File name
    # set statusline+=\ %f                                        # File path relative
    set statusline+=\ %.40F                                     # File path full
    # set statusline+=\ [%{g:FileSize()}]                         # File size
    # set statusline+=\ [%02p%%]                                  # Percentage
    set statusline+=\ %r%m%h                                    # Readonly,modified,help
    set statusline+=%=                                          # Right align
    set statusline+=\ %{FugitiveHead()}\                        # Git branch
    set statusline+=%*                                          # Default highlight
    set statusline+=%{exists('g:asyncdo')?'[running]':''}       # AsyncDo status
    # set statusline+=\ %{strlen(&fenc)?&fenc:'none'}\ \|         # File encoding
    set statusline+=\ %{&fileformat}\ \\|                       # File format
    set statusline+=\ %{strlen(&ft)?&ft:'none'}\ \\|            # Filetype
    set statusline+=\ %02c:%3l/%L\                              # Column:line/total
enddef
g:Statusline()

# Automatically resize splits on window resize
autocmd VimResized * wincmd =

# Clear jumplist at startup
autocmd VimEnter * exe 'clearjumps'

# :t to :tabe
cnoreabbrev <expr> t getcmdtype() == ":" && getcmdline() == 't' ? 'tabe' : 't'

# Open :h in new tab
cnoreabbrev <expr> h getcmdtype() == ":" && getcmdline() == 'h' ? 'tab help' : 'h'

# Scratch buffer
command! S vnew | setlocal nobuflisted buftype=nofile bufhidden=wipe

# Universal opposite of J
function g:BreakHere()
    s/^\(\s*\)\(.\{-}\)\(\s*\)\(\%#\)\(\s*\)\(.*\)/\1\2\r\1\4\6
    call histdel("/", -1)
endfunction

augroup FORMATOPTIONS | autocmd!
    autocmd FileType * setlocal formatoptions-=cro # Disable continuation of comments to the next line
    autocmd FileType * setlocal formatoptions+=j   # Remove a comment leader when joining lines
    autocmd FileType * setlocal formatoptions+=l   # Don't break a line after a one-letter word
    autocmd FileType * setlocal formatoptions+=n   # Recognize numbered lists
    autocmd FileType * setlocal formatoptions-=q   # Don't format comments
    autocmd FileType * setlocal formatoptions-=t   # Don't autowrap text using 'textwidth'
augroup END

def g:WipeHiddenBuffers()
    var buffers = filter(getbufinfo(), (_, v) => v.hidden)
    if !empty(buffers)
        execute 'confirm bwipeout' join(mapnew(buffers, (_, v) => v.bufnr))
    endif
enddef

# Set listchars visible in Visual Mode
# autocmd ModeChanged *:[vV\x16]* set list
# autocmd ModeChanged [vV\x16]*:* set nolist

# Remove all trailing whitespace and newlines at end of file & reset cursor position
var currPos = getpos(".")
autocmd BufWritePre * {
    currPos = getpos(".")
    :%s/\s\+$//e
    :%s/\n\+\%$//e
    cursor(currPos[1], currPos[2])
}

# O------------------------------------------------------------------O
# |  Mappings                                                        |
# O------------------------------------------------------------------O
inoremap <m-i> <Esc>

nnoremap <F1> <Esc>
inoremap <F1> <Esc>

nnoremap <m-j> 5j
nnoremap <m-k> 5k
vnoremap <m-j> 5j
vnoremap <m-k> 5k

nnoremap <space>G <Esc>:w<cr>
nnoremap <silent><space>q :q<cr>
tnoremap <silent><c-w>q exit<cr>
nnoremap <silent><space><cr> :vert term<cr>clink inject<cr><c-l>
nnoremap <silent><F7> :call BuildFile()<cr>

# Switching tabs
nnoremap gr gT

# Swap ` and ' for marks
nnoremap ' `
nnoremap ` '

# Change into void register
nnoremap c "_c
nnoremap C "_C

# Make Y behave like other capitals
nnoremap Y y$

# Clear search highlighting & refresh statusline
nnoremap <silent><c-l> :nohlsearch<cr>:call Statusline()<cr><c-l>

# Keeping it centered
nnoremap n nzzzv
nnoremap N Nzzzv

# Don't lose selection when shifting sidewards
xnoremap < <gv^
xnoremap > >gv^

# Moving lines
vnoremap <c-j> :m '>+1<cr>gv=gv
vnoremap <c-k> :m '<-2<cr>gv=gv

# Access to system clipboard
xnoremap <space>y "+y
nnoremap <space>p "+p
nnoremap <space>P "+P
tnoremap <s-insert> <c-w>"+
tnoremap <c-v> <c-w>"+

# Search & Replace ('g' global, 'c' confirm)
nnoremap <space>S :%s//gc<Left><Left><Left>
nnoremap <Space>s :%s/\<<C-r>=expand("<cword>")<CR>\>/

# Delete all occurences of selected text
xnoremap <space>d y:%s/<c-r>"//gc<cr>

# Change directory to current file
nnoremap <space>cd :cd %:p:h<cr>:pwd<cr>

# Saner command-line history
cnoremap <expr> <c-n> wildmenumode() ? "\<c-n>" : "\<down>"
cnoremap <expr> <c-p> wildmenumode() ? "\<c-p>" : "\<up>"

# Change forward/back slashes
nnoremap <silent><space>c/ :let tmp=@/<Bar>s:\\:/:ge<Bar>let @/=tmp<Bar>noh<CR>
nnoremap <silent><space>c<Bslash> :let tmp=@/<Bar>s:/:\\:ge<Bar>let @/=tmp<Bar>noh<CR>

# Fuzzy file search
nnoremap <space>. :find **

# File search
nnoremap <space>> :cd %:p:h<cr>:find <C-D>

# Perform dot commands over visual selections
xnoremap . :normal .<cr>

# J counterpart
nnoremap <silent>K :<c-u>call BreakHere()<cr>

# Auto-insert closing parenthesis/brace/quotes
inoremap ( ()<Left>
inoremap { {}<Left>
inoremap [ []<Left>
inoremap ' ''<Left>
inoremap " ""<Left>
# Expand opening-brace followed by ENTER to a block and place cursor inside
inoremap {<cr> {<cr>}<Esc>O
# Skip over closing parenthesis/brace
inoremap <expr> ) getline('.')[col('.') - 1] == ")" ? "\<Right>" : ")"
inoremap <expr> } getline('.')[col('.') - 1] == "}" ? "\<Right>" : "}"

# Terminal mode
if has("win32") && (&shell =~# '\<cmd\.exe$')
    tnoremap <silent><C-p> <up>
    tnoremap <silent><C-n> <down>
    tnoremap <silent><C-b> <left>
    tnoremap <silent><C-f> <right>
    tnoremap <silent><C-e> <end>
    tnoremap <silent><C-a> <home>
    tnoremap <silent><C-u> <esc>
endif

# Command mode
cnoremap <c-bs> <c-w>
cnoremap <c-h> <left>
cnoremap <c-l> <right>
cnoremap <c-e> <end>
cnoremap <c-a> <home>
cnoremap <esc> <c-c><esc>

# Insert mode (Emacs-ish)
inoremap <c-bs> <c-w>
inoremap <c-b> <left>
inoremap <c-f> <right>
inoremap <m-b> <c-left>
inoremap <m-f> <c-right>
inoremap <m-n> <c-o>j
inoremap <m-p> <c-o>k
inoremap <c-a> <home>
inoremap <c-e> <end>
inoremap <c-u> <c-g>u<c-u>
inoremap <silent><c-Up> <c-o>:<c-u>execute "keepjumps norm! " . v:count1 . "{"<cr>
inoremap <silent><c-Down> <c-o>:<c-u>execute "keepjumps norm! " . v:count1 . "}"<cr>
inoremap <s-Left> <Esc>v<c-g><Left>
inoremap <s-Right> <Esc>v<c-g><Right>
inoremap <c-s> <Esc>:w<cr>a
inoremap <c-l> <c-o><c-l>

# QuickFix
nnoremap <silent> ]q :cnext<CR>
nnoremap <silent> ]Q :clast<CR>
nnoremap <silent> [q :cprevious<CR>
nnoremap <silent> [Q :cfirst<CR>
nnoremap <silent> ]w :lnext<CR>
nnoremap <silent> ]W :llast<CR>
nnoremap <silent> [w :lprevious<CR>
nnoremap <silent> [W :lfirst<CR>

# Buffer navigation
nnoremap <bs> <c-^>
nnoremap <space>bn :bn<cr>
nnoremap <space>bp :bp<cr>
nnoremap <space>bd :bd<cr>
nnoremap <space>bw :bw<cr>
nnoremap <silent><space>bo :call g:WipeHiddenBuffers()<cr>
nnoremap <space>, :buffers<cr>:buffer<Space>

# Split navigation
nnoremap <space>w <c-w>
tnoremap <c-space> <c-w>p
tnoremap <c-w>N <C-\><C-n>
noremap <c-space> <c-w>w

# Split Resizing
nnoremap <silent><c-Up> :res +3<cr>
nnoremap <silent><c-Down> :res -3<cr>
nnoremap <silent><c-Left> :vert res +3<cr>
nnoremap <silent><c-Right> :vert res -3<cr>

nnoremap <silent><space>wm :call ToggleMaximizeSplit(v:true)<cr>

# FZF (plugin)
nnoremap <space>r :Rg<cr>
nnoremap <space>ff :FZF<cr>
nnoremap <space>fF :Files<cr>
nnoremap <space>fh :History<cr>
nnoremap <space>f: :History:<cr>
nnoremap <space>f/ :History/<cr>
nnoremap <space>fb :Buffers<cr>
nnoremap <space>fw :Windows<cr>
nnoremap <space>fm :Marks<cr>
nnoremap <space>fl :Lines<cr>
nnoremap <space>fc :Colors<cr>
# ! Opens in fullscreen
nnoremap <space>R :Rg!<cr>
nnoremap <space>Ff :FZF!<cr>
nnoremap <space>FF :Files!<cr>
nnoremap <space>Fh :History!<cr>
nnoremap <space>Fl :Lines!<cr>

# Toggles
if has("gui_running")
    if has("win32")
        nnoremap <silent><m-cr> <Esc>:call libcallnr("vimtweak.dll", "ToggleFullScreen", 0)<cr>
    endif
    nnoremap <silent><space>tb :if ScrollBar == 0 \| let ScrollBar = 1 \| set go+=r \| else \| let ScrollBar = 0 \| set go-=r \| endif<cr>
    nnoremap <silent><space>tg :if &guioptions == 'i' \| set go=imTrL \| else \| set go=i \| endif<cr>
endif
nnoremap <silent><c-q> :if empty(filter(getwininfo(), 'v:val.quickfix')) \| copen \| else \| cclose \| endif<cr>
nnoremap <silent><space><space> :call g:ToggleNetrw()<cr>
nnoremap <silent><space>ti :call g:ToggleIndentGuides()<cr>
nnoremap <silent><space>tw :set wrap! wrap?<cr>
nnoremap <silent><space>tl :set list! list?<cr>
nnoremap <silent><space>tn :set number! number?<cr>
nnoremap <silent><space>tt :if &showtabline != 0 \| set showtabline=0 \| else \| set showtabline=2 \| endif<cr>
nnoremap <silent><space>ts :if &laststatus == 2 \| set laststatus=0 \| else \| set laststatus=2 \| endif<cr>
nnoremap <silent><space>tf :if &foldcolumn == 1 \| setlocal foldcolumn=0 \| else \| setlocal foldcolumn=1 \| endif<cr>
nnoremap <silent><space>tc :let &bg=(&bg=="dark"?"light":"dark")<cr>
nnoremap <silent><space>tz :call DistractionFree()<CR>
nnoremap <silent><space>cc :call g:LoopColorSchemes()<CR>
nmap <silent><c-z> <Plug>(Multiterm)
tmap <silent><c-z> <Plug>(Multiterm)
